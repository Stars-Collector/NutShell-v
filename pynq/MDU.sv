// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for prints and assertions.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

module MDU(	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
  input         clock,	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
                reset,	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
                io_in_valid,	// src/main/scala/nutcore/backend/fu/MDU.scala:136:14
  input  [63:0] io_in_bits_src1,	// src/main/scala/nutcore/backend/fu/MDU.scala:136:14
                io_in_bits_src2,	// src/main/scala/nutcore/backend/fu/MDU.scala:136:14
  input  [6:0]  io_in_bits_func,	// src/main/scala/nutcore/backend/fu/MDU.scala:136:14
  output        io_out_valid,	// src/main/scala/nutcore/backend/fu/MDU.scala:136:14
  output [63:0] io_out_bits	// src/main/scala/nutcore/backend/fu/MDU.scala:136:14
);

  wire         io_in_ready;	// src/main/scala/nutcore/backend/fu/MDU.scala:182:21
  wire         _div_io_in_ready;	// src/main/scala/nutcore/backend/fu/MDU.scala:152:19
  wire         _div_io_out_valid;	// src/main/scala/nutcore/backend/fu/MDU.scala:152:19
  wire [127:0] _div_io_out_bits;	// src/main/scala/nutcore/backend/fu/MDU.scala:152:19
  wire         _mul_io_in_ready;	// src/main/scala/nutcore/backend/fu/MDU.scala:151:19
  wire         _mul_io_out_valid;	// src/main/scala/nutcore/backend/fu/MDU.scala:151:19
  wire [129:0] _mul_io_out_bits;	// src/main/scala/nutcore/backend/fu/MDU.scala:151:19
  wire         isDivSign = io_in_bits_func[2] & ~(io_in_bits_func[0]);	// src/main/scala/nutcore/backend/fu/MDU.scala:41:27, :42:{39,42,45}
  wire [64:0]  _mul_io_in_bits_0_T_4 = {1'h0, io_in_bits_src1};	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7, src/main/scala/utils/BitUtils.scala:49:41
  wire [64:0]  _mul_io_in_bits_1_T_4 = {1'h0, io_in_bits_src2};	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7, src/main/scala/utils/BitUtils.scala:49:41
  wire [63:0]  res =
    io_in_bits_func[2]
      ? (io_in_bits_func[1] ? _div_io_out_bits[127:64] : _div_io_out_bits[63:0])
      : (|(io_in_bits_func[1:0])) ? _mul_io_out_bits[127:64] : _mul_io_out_bits[63:0];	// src/main/scala/nutcore/backend/fu/MDU.scala:41:27, :151:19, :152:19, :166:39, :176:{19,69,96}, :177:{19,24,54,86}, :178:16, src/main/scala/utils/LookupTree.scala:24:34
  reg          isDivReg_REG;	// src/main/scala/nutcore/backend/fu/MDU.scala:181:48
  assign io_in_ready = io_in_bits_func[2] ? _div_io_in_ready : _mul_io_in_ready;	// src/main/scala/nutcore/backend/fu/MDU.scala:41:27, :151:19, :152:19, :182:21
  always @(posedge clock)	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
    isDivReg_REG <= io_in_bits_func[2];	// src/main/scala/nutcore/backend/fu/MDU.scala:41:27, :181:48
  `ifdef ENABLE_INITIAL_REG_	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
    `ifdef FIRRTL_BEFORE_INITIAL	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
      `FIRRTL_BEFORE_INITIAL	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
      automatic logic [31:0] _RANDOM[0:0];	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
      `ifdef INIT_RANDOM_PROLOG_	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
        `INIT_RANDOM_PROLOG_	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
        isDivReg_REG = _RANDOM[/*Zero width*/ 1'b0][0];	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7, :181:48
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
      `FIRRTL_AFTER_INITIAL	// src/main/scala/nutcore/backend/fu/MDU.scala:135:7
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Multiplier mul (	// src/main/scala/nutcore/backend/fu/MDU.scala:151:19
    .clock        (clock),
    .reset        (reset),
    .io_in_ready  (_mul_io_in_ready),
    .io_in_valid  (io_in_valid & ~(io_in_bits_func[2])),	// src/main/scala/nutcore/backend/fu/MDU.scala:41:27, :173:{34,37}
    .io_in_bits_0
      (((|(io_in_bits_func[1:0])) ? 65'h0 : _mul_io_in_bits_0_T_4)
       | (io_in_bits_func[1:0] == 2'h1 ? {io_in_bits_src1[63], io_in_bits_src1} : 65'h0)
       | (io_in_bits_func[1:0] == 2'h2 ? {io_in_bits_src1[63], io_in_bits_src1} : 65'h0)
       | ((&(io_in_bits_func[1:0])) ? _mul_io_in_bits_0_T_4 : 65'h0)),	// src/main/scala/chisel3/util/Mux.scala:30:73, src/main/scala/nutcore/backend/fu/MDU.scala:166:39, src/main/scala/utils/BitUtils.scala:41:20, :42:41, :49:41, src/main/scala/utils/LookupTree.scala:24:34
    .io_in_bits_1
      (((|(io_in_bits_func[1:0])) ? 65'h0 : _mul_io_in_bits_1_T_4)
       | (io_in_bits_func[1:0] == 2'h1 ? {io_in_bits_src2[63], io_in_bits_src2} : 65'h0)
       | (io_in_bits_func[1:0] == 2'h2 ? _mul_io_in_bits_1_T_4 : 65'h0)
       | ((&(io_in_bits_func[1:0])) ? _mul_io_in_bits_1_T_4 : 65'h0)),	// src/main/scala/chisel3/util/Mux.scala:30:73, src/main/scala/nutcore/backend/fu/MDU.scala:166:39, src/main/scala/utils/BitUtils.scala:41:20, :42:41, :49:41, src/main/scala/utils/LookupTree.scala:24:34
    .io_out_valid (_mul_io_out_valid),
    .io_out_bits  (_mul_io_out_bits)
  );
  wire         _GEN;	// src/main/scala/nutcore/backend/fu/MDU.scala:187:33
  assign _GEN = _mul_io_out_valid;	// src/main/scala/nutcore/backend/fu/MDU.scala:151:19, :187:33
  Divider div (	// src/main/scala/nutcore/backend/fu/MDU.scala:152:19
    .clock        (clock),
    .reset        (reset),
    .io_in_ready  (_div_io_in_ready),
    .io_in_valid  (io_in_valid & io_in_bits_func[2]),	// src/main/scala/nutcore/backend/fu/MDU.scala:41:27, :174:34
    .io_in_bits_0
      (io_in_bits_func[3]
         ? {{32{isDivSign & io_in_bits_src1[31]}}, io_in_bits_src1[31:0]}
         : io_in_bits_src1),	// src/main/scala/nutcore/backend/fu/MDU.scala:42:39, :43:25, :169:{38,47,68}, src/main/scala/utils/BitUtils.scala:41:20, :42:{41,46}, :49:41
    .io_in_bits_1
      (io_in_bits_func[3]
         ? {{32{isDivSign & io_in_bits_src2[31]}}, io_in_bits_src2[31:0]}
         : io_in_bits_src2),	// src/main/scala/nutcore/backend/fu/MDU.scala:42:39, :43:25, :169:{38,47,68}, src/main/scala/utils/BitUtils.scala:41:20, :42:{41,46}, :49:41
    .io_sign      (isDivSign),	// src/main/scala/nutcore/backend/fu/MDU.scala:42:39
    .io_out_valid (_div_io_out_valid),
    .io_out_bits  (_div_io_out_bits)
  );
  assign io_out_valid =
    (io_in_ready & io_in_valid ? io_in_bits_func[2] : isDivReg_REG)
      ? _div_io_out_valid
      : _mul_io_out_valid;	// src/main/scala/chisel3/util/Decoupled.scala:51:35, src/main/scala/nutcore/backend/fu/MDU.scala:41:27, :135:7, :151:19, :152:19, :181:{21,48}, :182:21, :183:22
  assign io_out_bits = io_in_bits_func[3] ? {{32{res[31]}}, res[31:0]} : res;	// src/main/scala/nutcore/backend/fu/MDU.scala:43:25, :135:7, :178:16, :179:{21,38}, src/main/scala/utils/BitUtils.scala:41:20, :42:{41,46}
endmodule

